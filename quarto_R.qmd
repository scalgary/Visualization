---
title: "matplotlib demo"
format:
  html:
    code-fold: true
    embed-resources: true
jupyter: python3
---

For a demonstration of a line plot on a polar axis, see @fig-polar.

```{python}
#| label: fig-polar
#| fig-cap: "A line plot on a polar axis"

import matplotlib.pyplot as plt
import pandas as pd
import json

# dataset 1

# dataset 1
url1 = "https://raw.githubusercontent.com/JosephBARBIERDARNAL/data-matplotlib-journey/main/storms/storms.csv"
import matplotlib.pyplot as plt
import pandas as pd



# dataset 2
url2 = "https://raw.githubusercontent.com/JosephBARBIERDARNAL/data-matplotlib-journey/refs/heads/main/footprint/footprint.csv"


# dataset 3
url3= "https://raw.githubusercontent.com/JosephBARBIERDARNAL/data-matplotlib-journey/refs/heads/main/mariokart/mariokart.csv"

df_storms = pd.read_csv(url1)
df_footprint = pd.read_csv(url2)
df_marioKart = pd.read_csv(url3)


url4 = "https://raw.githubusercontent.com/JosephBARBIERDARNAL/data-matplotlib-journey/refs/heads/main/natural-disasters/natural-disasters.csv"
df_desasters = pd.read_csv(url4)
print(plt.rcParams.keys())

```

## Visualisation Stroms data
## line plot





```{python}
import matplotlib.pyplot as plt

# Supposons que df_storms existe déjà

total_year = df_storms.groupby('year')["n"].sum()
grouped = df_storms.groupby("status")
df_storms_max = df_storms.sort_values(['status', 'n'], ascending=[True, False]) \
           .drop_duplicates(subset='status') \
           [['status', 'year', 'n']]
fig, ax = plt.subplots()

params = {
    "title": "Annual numbers of storms by status",
    "xlabel": "Year",
    "ylabel": "Number of storms",
    "xlim": [2010, 2022], 
    #"ylim": [0,400],
    "spines": {
        "top": False,
        "right": False
    },
    "ticks": {
        "top": False,
        "right": False
    },
    "legend": {
        "loc": "upper left",
        "frameon": False
    }
}

lines = []
nudge_y = [5,-8,5,5]
nudge_x = [0,0,0,0]
# Tracer les groupes
for i, (status, df_grouped) in enumerate(grouped):
    df_value = df_grouped.sort_values(["n"], ascending=[False]).head(1)
    line, = ax.plot(df_grouped["year"], df_grouped["n"], label=status.capitalize())
    lines.append(line)  # stocker l'objet Line2D
    ax.text(df_value["year"].iloc[0] + nudge_x[i],df_value["n"].iloc[0] + nudge_y[i], f"{int(df_value.iloc[0]["n"])}", color = line.get_color())
    

# Handlers pour appliquer les paramètres
handlers = {
    "title":   {"func": ax.set_title,  "kind": "single"},
    "xlabel":  {"func": ax.set_xlabel, "kind": "single"},
    "ylabel":  {"func": ax.set_ylabel, "kind": "single"},
    "xlim":    {"func": ax.set_xlim,   "kind": "args"},
    "ylim":    {"func": ax.set_ylim,   "kind": "args"},
    "legend":  {"func": ax.legend,     "kind": "kwargs"},
    "ticks":   {"func": ax.tick_params,"kind": "kwargs"}
}

legend = None  # pour pouvoir accéder à l’objet ensuite si nécessaire

for key, conf in handlers.items():
    if key in params:
        value = params[key]
        kind = conf["kind"]
        func = conf["func"]
        
        if kind == "single":
            func(value)
        elif kind == "args":
            func(*value)
        elif kind == "kwargs":
            result = func(**value)
            if key == "legend":
                legend = result  # capturer l'objet Legend

# Gérer les spines
for spine, visible in params.get("spines", {}).items():
    ax.spines[spine].set_visible(visible)

# Couleur du texte = couleur de la ligne
# Appliquer la couleur de la courbe au texte de la légende
for text, line in zip(legend.get_texts(), lines):
    text.set_color(line.get_color())

ymin, _ = ax.get_ylim()  # récupérer le min actuel
ax.set_ylim(ymin, 400)
ax.set_xticks(list(range(2010, 2023))) 
#plt.xticks(rotation=90)  # ou 90 si besoin
ax.tick_params(axis='x', labelsize=8)
plt.show()
```

je veux boxplot des lifexp par region
```{python}
df_clean = df_footprint.dropna(subset=["lifexp"])
region_means = df_clean.groupby("region")["lifexp"].mean()
regions_sorted = region_means.sort_values().index.tolist()

values = [df_clean[df_clean["region"] == region]["lifexp"] for region in regions_sorted]
fig, ax = plt.subplots()
params = {
    "title": "Life Esperance by region",
    "xlabel": "Years",
    "spines": {
        "top": False,
        "right": False,
        "left":False
    },
    "ticks": {
        "top": False,
        "right": False,
        "left":False
    }
}


# Handlers pour appliquer les paramètres
handlers = {
    "title":   {"func": ax.set_title,  "kind": "single"},
    "xlabel":  {"func": ax.set_xlabel, "kind": "single"},
    "ylabel":  {"func": ax.set_ylabel, "kind": "single"},
    "xlim":    {"func": ax.set_xlim,   "kind": "args"},
    "ylim":    {"func": ax.set_ylim,   "kind": "args"},
    "legend":  {"func": ax.legend,     "kind": "kwargs"},
    "ticks":   {"func": ax.tick_params,"kind": "kwargs"}
}

legend = None  # pour pouvoir accéder à l’objet ensuite si nécessaire

for key, conf in handlers.items():
    if key in params:
        value = params[key]
        kind = conf["kind"]
        func = conf["func"]
        
        if kind == "single":
            func(value)
        elif kind == "args":
            func(*value)
        elif kind == "kwargs":
            result = func(**value)
            if key == "legend":
                legend = result  # capturer l'objet Legend

# Gérer les spines
for spine, visible in params.get("spines", {}).items():
    ax.spines[spine].set_visible(visible)





ax.boxplot(values, labels = regions_sorted, vert = False)
plt.show()
```

import matplotlib.colors as mcolors

hsv_color = (0.01, .4, .8)
rgb_color = mcolors.hsv_to_rgb(hsv_color)

from pypalettes import load_cmap


```{python}
import pandas as pd

import matplotlib.pyplot as plt


pivot_df = df_storms.pivot_table(
  index="year",  # year is now the index
  columns="status",  # column are the kind of storm
  values="n",  # df content is taken from the 'n' column
)

fig, ax = plt.subplots()

for status in pivot_df["status"].unique():
  if status == "tropical storm":
      color = "#b75050"
  else:
      color = "lightgrey"
  ax.plot(pivot_df.index, pivot_df[status], color=color)

plt.show()
```


```{python}
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from pypalettes import load_cmap




x = df_storms["year"]
y = df_storms["n"]
c = df_storms["status"]

cmap = load_cmap("Acadia")

fig, ax = plt.subplots()
sns.lineplot(
  x=x, y=y, hue=c,
  palette=cmap.colors,
  ax=ax
)
plt.show()
```


```{python}
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

from pypalettes import load_cmap

df = df_desasters.copy()

columns = df.drop(columns="Year").sum().sort_values().index.to_list()
x = df["Year"]
y = np.stack(df[columns].values, axis=-1)

fig, ax = plt.subplots(figsize=(10, 5))
#stacked lineplot

ax.stackplot(x, y, labels=x)
ax.spines[spine].set_visible(visible)

plt.show()
# Here goes your code
```